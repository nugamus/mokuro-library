# Feature Spec: OCR Editing & Smart Resize

## 1. Overview & Goal
**Goal:** To provide a robust, browser-based editor for correcting OCR text and bounding boxes generated by the Mokuro tool.

**User Story:** A user notices incorrect Japanese text or a misaligned speech bubble while reading. They toggle "Edit Mode," fix the text, resize the box to fit, and save the changes directly back to the source `.mokuro` file on the server.

**Philosophy:** Achieve full data parity with the source `.mokuro` file format and lay the groundwork for a future centralized, user-audited OCR database.
1.  **Data Integrity:** It ensures that saved files match the exact schema of machine-generated files, preventing data loss or "drift" during the editing process.
2.  **Future Infrastructure:** It standardizes the data format for human corrections, facilitating the creation of a shared, high-quality dataset that can eventually be used to train better OCR models or sync corrections across the community.

## 2. Technical Architecture

The editor uses a **Composition Pattern** backed by a dedicated **State Class** (`OcrState.svelte.ts`). This decouples the editor's logic and global state from the visual components. For full details, refer to the [architecture doc](../architecture/OcrOverlay.md).


### 2.1. OcrState Management
The `OcrState` class acts as the single source of truth, managing:
* **Context:** References to the `page` data, `panzoomInstance`, and `overlayElement`.
* **Calculations:** Automatically derives `fontScale` based on the rendered container dimensions and current zoom level.
* **Modes:** Reactive boolean flags that determine interaction behavior (`isEditMode`, `isBoxEditMode`, `isSmartResizeMode`).
* **View Options:**
    * `showTriggerOutline`: Toggles the visibility of hover triggers for OCR blocks.
    * `readingDirection`: Tracks the current reading direction (`rtl` vs `ltr`) to adjust arrow key navigation logic.
* **Focus Tracking:** Uses `focusedBlock` to implement "Sticky Focus," ensuring the editing UI remains active even when interacting with external toolbars (like the font size slider).

### 2.2. Editor Modes
* **`isEditMode` (Text Mode):** Enables `contenteditable` on text lines.
    * *Interaction:* Click to type, Enter to split lines.
    * *Constraint:* Mutually exclusive with `isBoxEditMode`.
* **`isBoxEditMode` (Layout Mode):** Enables drag-and-drop and resize handles.
    * *Interaction:* Drag blocks/lines, resize handles.
    * *Constraint:* Mutually exclusive with `isEditMode`.
* **`isSmartResizeMode` (Helper Mode):** A modifier state that runs the auto-sizing logic.
    * *Behavior:* Can be active alongside either of the above modes.
    * *Trigger:* Automatically recalculates font size when text content or box dimensions change.

## 3. Implementation Details

### 3.1. Text Rendering & Ligatures
Since mangaOCR doesn't seem to be able to output complex characters, text content is processed before rendering.
* **Function:** `ligaturize(text)` in `src/lib/utils/ocrMath.ts`.
* **Logic:** Replaces specific character sequences (like `...`, `!!`, `!?`) with their single-character Unicode equivalents (e.g., `\u2026`, `\u203C`, `\u2049`).

### 3.2. Box Manipulation (Box Edit Mode)
* **Dragging:**
    * **Visual:** Uses CSS `transform: translate(...)` for smooth rendering during the drag.
    * **Commit:** On `mouseup`, the delta is calculated using `getDeltas()` (which accounts for zoom level), applied to the absolute coordinates in the data model, and the CSS transform is reset.
* **Resize Handles:**
    * **Component:** `ResizeHandles.svelte` renders 8 interactive control points (Corners: TL, TR, BL, BR; Edges: Top, Bottom, Left, Right).
    * **Visual Feedback:**
        * **Block Handles (Outer):** Blue squares (`bg-blue-500`, 8x8px) that appear on hover.
        * **Line Handles (Inner):** Yellow squares (`bg-yellow-400`, 6x6px) that appear on hover.
* **Resizing Logic:**
    * **Outer Block:** Updates `block.box`. Does *not* affect inner lines (lines have absolute coordinates).
    * **Inner Line:** Updates `block.lines_coords[i]`.

### 3.3. Text Manipulation (Text Edit Mode)
* **DOM Structure:** Text is rendered inside a nested `div` with `contenteditable="true"`, isolated from the drag handlers to prevent event conflicts.
* **Line Splitting:**
    * **Trigger:** User presses `Enter` inside a line.
    * **Logic:** The system intercepts the keystroke, splits the string at the cursor position, and creates a new entry in `block.lines`.
    * **Placement:**
        * *Horizontal:* New line appears below.
        * *Vertical:* New line appears to the left (following Japanese reading order).
* **Line Merging:**
    * **Trigger:** User presses `Backspace` while the caret is at the **start** (offset 0) of a line.
    * **Logic:**
        1.  The current line's text is appended to the end of the **previous** line.
        2.  The current line entry is removed from `block.lines`.
        3.  The cursor focus is automatically moved to the merge point in the previous line.
* **Navigation:** `Arrow` keys move focus between adjacent lines within the block, respecting the `readingDirection` state.

### 3.4. Structural Management
* **Context Menus:**
    * **Create Block:** Right-click on empty background -> Creates new `MokuroBlock`.
    * **Create Line:** Right-click on Block -> Adds new line entry.
    * **Delete:** Right-click on Line -> Removes line. (If it is the last line, removes the entire Block).
* **Re-ordering:**
    * **Problem:** Text selection order relies on the `block.lines` array order. Visual position does not always match array index.
    * **Solution:** A dedicated "Re-order Lines" modal allows users to swap array indices manually.

## 4. Feature Detail: Smart Resize Logic

This feature automatically calculates the maximum font size that fits a line of text within its bounding box.

### 4.1. Algorithm (`smartResizeFont`)
* **Location:** `src/lib/utils/ocrMath.ts`
* **Input:**
    * `block`: The mutable `MokuroBlock` data.
    * `lineElement`: The actual DOM element containing the text (for measurement).
    * `imgWidth`: The original width of the image (defines max bounds).
    * `fontScale`: The current visual scale ratio derived from `OcrState`.
* **Logic:**
    1.  Determines the **Primary Axis** based on block orientation (Vertical = Height, Horizontal = Width).
    2.  Reads the target dimension (in pixels) from the parent container's bounding box.
    3.  Performs a **Binary Search** (usually ends in a few iterations) on the `font-size` CSS property.
    4.  Checks the rendered `rect` of the DOM element until it fits the target dimension.
* **Scope:** The `.mokuro` format defines `font_size` at the **Block Level**. Therefore, resizing *one* line triggers a recalculation that applies the new font size to the *entire* block.

## 5. Persistence Strategy

* **State Management:** All edits mutate the local Svelte reactive state (`mokuroData`).
* **Dirty Checking:** Any change triggers the `onOcrChange` callback in `OcrState`, which sets a `unsavedChanges` flag in the UI.
* **Write-Back:**
    * **Endpoint:** `PUT /api/library/volume/:id/ocr`
    * **Payload:** The backend expects an **Array** of page data (`MokuroPage[]`), not the full `.mokuro` JSON object.
    * **Process:** The backend reads the existing file, replaces the `pages` property with the incoming array, and writes the file back to disk.
